Push content
===============

This doctest gives an overview about pushing content to be synchronized.

Setting up
----------

    >>> from DateTime import DateTime

    Create a Document
    >>> _ = folder.invokeFactory(id='mydoc', type_name='Document')
    >>> doc = folder[_]
    >>> doc.unmarkCreationFlag()
    >>> doc.id
    'mydoc'

    Give it a fake UID
    >>> doc._at_uid = '1'

    Create some data
    >>> mydata = dict(id='mydoc', title='doctitle', description='docdescription')
    >>> doc.processForm(data=1, values=mydata)



    Mockup class that provides interface functionality of the receiving end
    >>> class XMLRPCProxy(object):
    ...   UIDS = dict()
    ...   def __init__(self, id):
    ...     self.id = id
    ...
    ...   def getSyncStatus(self, remote_uid):
    ...     """ looks up the remote uid in the local utility to get the local uid.
    ...     resolves the object using the local uid
    ...     returns the modification date of the referenced object or None, if no such object exists
    ...     as well as the link of the object"""
    ...     return self.UIDS.get(remote_uid, (None, None))
    ...
    ...   def syncObject(self, portal_type, data={}, remote_uid=None, translation_reference_uid=None):
    ...     """ check if an object to the given remote_uid exists
    ...     if not, create one using the portal_type
    ...     update its data using the data mapping
    ...     returns a feedback message and the link of the object in question """
    ...     if self.UIDS.has_key(remote_uid):
    ...       msg = 'Object was modified'
    ...       date = self.UIDS[remote_uid][0]
    ...     else:
    ...       msg = 'Object was created'
    ...       date = 0
    ...     link = 'http://osha.europa.eu/%s/%s' %(portal_type, data['id'])
    ...     self.UIDS[remote_uid] = (date + 1, link)
    ...     return msg, link

Testing the connection
----------------------

    Initialize XMLRPCProxy
    >>> proxy = XMLRPCProxy('proxy')

    Our Document has never been synchronized before:
    >>> proxy.getSyncStatus(doc.UID())
    (None, None)

    Now we synchronize for the first time
    >>> proxy.syncObject(doc.portal_type, mydata, doc.UID())
    ('Object was created', 'http://osha.europa.eu/Document/mydoc')

    So now we have a status:
    >>> proxy.getSyncStatus(doc.UID())
    (1, 'http://osha.europa.eu/Document/mydoc')

    We synchronize again
    >>> proxy.syncObject(doc.portal_type, mydata, doc.UID())
    ('Object was modified', 'http://osha.europa.eu/Document/mydoc')

    And the status returns a 'newer' date
    >>> proxy.getSyncStatus(doc.UID())
    (2, 'http://osha.europa.eu/Document/mydoc')


Testing the BrowserView
-----------------------

    Get the BrowserView that handles synchronisation
    >>> bv = doc.restrictedTraverse('synchronize_content')
    >>> bv.setProxy(proxy)

    We should get the identical sync status as before
    >>> bv.getSyncStatus()
    (2, 'http://osha.europa.eu/Document/mydoc')

    And synching should also work...
    >>> bv.syncObject(doc.portal_type, mydata, doc.UID())
    ('Object was modified', 'http://osha.europa.eu/Document/mydoc')

    so that "date" is updated again
    >>> bv.getSyncStatus()
    (3, 'http://osha.europa.eu/Document/mydoc')


Testing the Extractor
---------------------

    >>> from slc.synchronizer.interfaces import IDataExtractor

    Apply the extracting adapter to the Document and call it to retrieve the data
    >>> extractor = IDataExtractor(doc)
    >>> data = extractor()

    We should get a mapping
    >>> isinstance(data, dict)
    True

    The title is present in the mapping, and corresponds to the one we set
    >>> data.get('title', '')
    'doctitle'

    Metadata fields are alo part of the data.
    >>> data.has_key('rights')
    True

    >>> #import pdb; pdb.set_trace()